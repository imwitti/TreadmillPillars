Directory structure and file contents of: C:\Users\mzh\OneDrive - Danaher\Documents\GitHub\TreadmillPillars\TreadmillPillars\TreadmillPillars

[Folder] .git/
    [Folder] hooks/
    [Folder] info/
    [Folder] logs/
        [Folder] refs/
            [Folder] heads/
            [Folder] remotes/
                [Folder] origin/
    [Folder] objects/
        [Folder] 00/
        [Folder] 01/
        [Folder] 02/
        [Folder] 04/
        [Folder] 05/
        [Folder] 06/
        [Folder] 08/
        [Folder] 09/
        [Folder] 0a/
        [Folder] 0d/
        [Folder] 0e/
        [Folder] 0f/
        [Folder] 11/
        [Folder] 12/
        [Folder] 13/
        [Folder] 14/
        [Folder] 15/
        [Folder] 16/
        [Folder] 18/
        [Folder] 19/
        [Folder] 1b/
        [Folder] 1d/
        [Folder] 20/
        [Folder] 21/
        [Folder] 22/
        [Folder] 24/
        [Folder] 25/
        [Folder] 26/
        [Folder] 27/
        [Folder] 28/
        [Folder] 29/
        [Folder] 2a/
        [Folder] 2d/
        [Folder] 2e/
        [Folder] 2f/
        [Folder] 31/
        [Folder] 33/
        [Folder] 34/
        [Folder] 36/
        [Folder] 37/
        [Folder] 3a/
        [Folder] 3b/
        [Folder] 3d/
        [Folder] 3e/
        [Folder] 3f/
        [Folder] 40/
        [Folder] 42/
        [Folder] 43/
        [Folder] 44/
        [Folder] 46/
        [Folder] 48/
        [Folder] 49/
        [Folder] 4b/
        [Folder] 4c/
        [Folder] 4d/
        [Folder] 4e/
        [Folder] 51/
        [Folder] 52/
        [Folder] 53/
        [Folder] 54/
        [Folder] 55/
        [Folder] 56/
        [Folder] 58/
        [Folder] 59/
        [Folder] 5b/
        [Folder] 5c/
        [Folder] 5d/
        [Folder] 5e/
        [Folder] 5f/
        [Folder] 61/
        [Folder] 62/
        [Folder] 64/
        [Folder] 65/
        [Folder] 67/
        [Folder] 68/
        [Folder] 69/
        [Folder] 6a/
        [Folder] 6b/
        [Folder] 6c/
        [Folder] 6d/
        [Folder] 6e/
        [Folder] 6f/
        [Folder] 71/
        [Folder] 72/
        [Folder] 73/
        [Folder] 74/
        [Folder] 77/
        [Folder] 78/
        [Folder] 79/
        [Folder] 7a/
        [Folder] 7b/
        [Folder] 7d/
        [Folder] 7e/
        [Folder] 80/
        [Folder] 81/
        [Folder] 83/
        [Folder] 84/
        [Folder] 86/
        [Folder] 89/
        [Folder] 8a/
        [Folder] 8b/
        [Folder] 8c/
        [Folder] 8f/
        [Folder] 90/
        [Folder] 91/
        [Folder] 92/
        [Folder] 93/
        [Folder] 95/
        [Folder] 96/
        [Folder] 97/
        [Folder] 9b/
        [Folder] 9d/
        [Folder] 9e/
        [Folder] a0/
        [Folder] a1/
        [Folder] a2/
        [Folder] a3/
        [Folder] a5/
        [Folder] a7/
        [Folder] a8/
        [Folder] a9/
        [Folder] ab/
        [Folder] ac/
        [Folder] ad/
        [Folder] ae/
        [Folder] af/
        [Folder] b2/
        [Folder] b3/
        [Folder] b5/
        [Folder] b6/
        [Folder] b7/
        [Folder] b9/
        [Folder] ba/
        [Folder] bb/
        [Folder] bc/
        [Folder] bd/
        [Folder] bf/
        [Folder] c0/
        [Folder] c1/
        [Folder] c2/
        [Folder] c3/
        [Folder] c5/
        [Folder] c6/
        [Folder] c7/
        [Folder] c8/
        [Folder] c9/
        [Folder] ca/
        [Folder] cb/
        [Folder] cc/
        [Folder] ce/
        [Folder] d1/
        [Folder] d3/
        [Folder] d6/
        [Folder] d7/
        [Folder] d8/
        [Folder] d9/
        [Folder] db/
        [Folder] dd/
        [Folder] de/
        [Folder] df/
        [Folder] e0/
        [Folder] e1/
        [Folder] e2/
        [Folder] e4/
        [Folder] e6/
        [Folder] e7/
        [Folder] e8/
        [Folder] e9/
        [Folder] ea/
        [Folder] eb/
        [Folder] ec/
        [Folder] ed/
        [Folder] ee/
        [Folder] ef/
        [Folder] f0/
        [Folder] f2/
        [Folder] f3/
        [Folder] f4/
        [Folder] f5/
        [Folder] f6/
        [Folder] f8/
        [Folder] f9/
        [Folder] fb/
        [Folder] fc/
        [Folder] fd/
        [Folder] fe/
        [Folder] ff/
        [Folder] info/
        [Folder] pack/
    [Folder] refs/
        [Folder] heads/
        [Folder] remotes/
            [Folder] origin/
        [Folder] tags/
[Folder] Ancillaries/
    [File] log_ftms_data.py
    --- Start of log_ftms_data.py ---
    import asyncio
    import json
    import time
    from datetime import datetime
    from bleak import BleakScanner, BleakClient
    
    FTMS_SERVICE_UUID = "00001826-0000-1000-8000-00805f9b34fb"
    TREADMILL_DATA_UUID = "00002ACD-0000-1000-8000-00805f9b34fb"
    
    log_file = "treadmill_log.json"
    log_data = []
    
    def parse_treadmill_data(data: bytearray):
        flags = int.from_bytes(data[0:2], byteorder='little')
        idx = 2
    
        speed = distance = elapsed_time = incline = None
    
        if flags & 0x01:  # Bit 0 = speed present
            speed = int.from_bytes(data[idx:idx+2], 'little') / 100.0
            idx += 2
    
        if flags & 0x04:  # Bit 2 = distance present
            distance = int.from_bytes(data[idx:idx+3], 'little') / 1000.0
            idx += 3
    
        if flags & 0x08:  # Bit 3 = incline present
            incline = int.from_bytes(data[idx:idx+2], 'little', signed=True) / 10.0
            idx += 2
    
        if flags & 0x0400:  # Bit 10 = elapsed time present
            elapsed_time = int.from_bytes(data[idx:idx+3], 'little')
            idx += 3
    
        return {
            "speed_kmh": speed,
            "distance_km": distance,
            "incline_percent": incline,
            "elapsed_time_s": elapsed_time,
        }
    
    def notification_handler(_, data: bytearray):
        parsed = parse_treadmill_data(data)
        entry = {
            "timestamp": datetime.now().isoformat(),
            "raw": data.hex(),
            "parsed": parsed
        }
        log_data.append(entry)
        print(f"[{entry['timestamp']}] {parsed}")
    
    async def main():
        print("Scanning for treadmill...")
        devices = await BleakScanner.discover()
    
        treadmill = None
        for device in devices:
            if FTMS_SERVICE_UUID.lower() in [uuid.lower() for uuid in device.metadata.get("uuids", [])]:
                treadmill = device
                break
    
        if not treadmill:
            print("Treadmill with FTMS service not found.")
            return
    
        print(f"Connecting to {treadmill.name} ({treadmill.address})...")
        async with BleakClient(treadmill.address) as client:
            print("Connected. Subscribing to treadmill data notifications...")
            await client.start_notify(TREADMILL_DATA_UUID, notification_handler)
    
            try:
                print("Logging for 60 seconds... (Ctrl+C to stop early)")
                await asyncio.sleep(60)
            except KeyboardInterrupt:
                print("Stopped by user.")
    
            await client.stop_notify(TREADMILL_DATA_UUID)
    
        with open(log_file, "w") as f:
            json.dump(log_data, f, indent=2)
        print(f"Saved log to {log_file}")
    
    if __name__ == "__main__":
        asyncio.run(main())
    --- End of log_ftms_data.py ---

    [File] shrinkvideos.py
    --- Start of shrinkvideos.py ---
    import cv2
    
    def convert_video(input_path, output_path, width=640, height=380, codec='MJPG', fps=30):
        # Open the input video
        cap = cv2.VideoCapture(input_path)
        if not cap.isOpened():
            print("Error: Cannot open the video file.")
            return
    
        # Get the original frame rate if available
        original_fps = cap.get(cv2.CAP_PROP_FPS)
        if original_fps > 0:
            fps = min(fps, original_fps)
    
        # Define the codec and create VideoWriter object
        fourcc = cv2.VideoWriter_fourcc(*codec)
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
    
        while True:
            ret, frame = cap.read()
            if not ret:
                break
    
            # Resize the frame
            resized_frame = cv2.resize(frame, (width, height))
    
            # Write the frame to the output video
            out.write(resized_frame)
    
        # Release everything
        cap.release()
        out.release()
        print(f"Video conversion complete. Saved to {output_path}")
    
    # Example usage:
    convert_video('forestrun_8.33_5.0.mp4', 'forestrun_8.33_5.0.avi')
    --- End of shrinkvideos.py ---

[Folder] Animations/
[File] RoutineSender.py
--- Start of RoutineSender.py ---
import sys
import asyncio
import pygame
import platform
import json
import os
import subprocess
from pathlib import Path
from post_workout_stats import show_post_workout_stats
from RunRoutine import exercise_routine
from zwo_parser import load_all_zwo_routines
from menu_ui import run_selection_ui

# Constants
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
FONT_SIZE = 36

pygame.init()
screen = pygame.display.set_mode((800, 600), pygame.FULLSCREEN)
pygame.display.set_caption("Routine Selector")
font = pygame.font.Font(None, FONT_SIZE)

def disable_screensaver():
    if platform.system() == "Linux":
        os.system("xset s off")
        os.system("xset -dpms")
        os.system("xset s noblank")

def load_user_config(config_path='user_config.json'):
    try:
        with open(config_path, 'r') as file:
            return json.load(file)
    except Exception:
        return {}

def load_routines(file_path):
    try:
        with open(file_path, 'r') as file:
            return json.load(file)
    except Exception:
        return {}

def list_videos(video_folder):
    videos = []
    for file in os.listdir(video_folder):
        if file.lower().endswith(('.mp4','.avi')):
            name, speed, distance = parse_video_title(file)
            videos.append((file, name, float(speed), float(distance)))
    return videos

def parse_video_title(title):
    base = os.path.splitext(title)[0]
    parts = base.split('_')
    return parts[0].lower(), parts[1], parts[2]

def run_thumbnail_generators():
    print("Generating thumbnails...")
    routines_script = Path('routines') / 'generate_zwo_thumbnail.py'
    if routines_script.exists():
        subprocess.run([sys.executable, str(routines_script.name)], cwd='routines')
    else:
        print("ZWO thumbnail generator not found.")

    videos_script = Path('videos') / 'video_thumbnails.py'
    if videos_script.exists():
        subprocess.run([sys.executable, str(videos_script.name)], cwd='videos')
    else:
        print("Video thumbnail generator not found.")

def display_pb_times(screen, font, pb_times):
    background_image = pygame.image.load("assets/background.jpg").convert()
    background_image = pygame.transform.scale(background_image, screen.get_size())
    screen.blit(background_image, (0, 0))
    y = 100
    screen_width = screen.get_width()
    for km_str in ["1", "3", "5", "10", "21"]:
        if km_str in pb_times:
            km = float(km_str)
            speed = km / (pb_times[km_str] / 60)
            text_str = f"PB {km_str}km: {pb_times[km_str]:.1f} min Speed: {speed:.1f} kmph"
            txt_surface = font.render(text_str, True, (255, 255, 255))
            text_rect = txt_surface.get_rect(center=(screen_width // 2, y))
            screen.blit(txt_surface, text_rect)
            y += 50
    pygame.display.flip()
    pygame.time.wait(5000)

def show_status(screen, font, message):
    screen.fill(BLACK)
    text = font.render(message, True, WHITE)
    rect = text.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2))
    screen.blit(text, rect)
    pygame.display.flip()

async def main():
    disable_screensaver()
    user_config = load_user_config()
    pb_times = user_config.get("pb_times_minutes", {})
    display_pb_times(screen, font, pb_times)

    pb_5k = pb_times.get("5", 25.0)
    zwo_speed = (5 * 60) / pb_5k

    show_status(screen, font, "Generating thumbnails...")
    run_thumbnail_generators()

    show_status(screen, font, "Loading routines...")
    json_routines = load_routines('routines.json')
    zwo_routines = load_all_zwo_routines('routines', zwo_speed)  # should return {name: {"type": ..., "segments": [...]}}
    routines = {**json_routines, **zwo_routines}

    show_status(screen, font, "Loading videos...")
    videos = list_videos('videos')
    video_data = [(v[0], f"{v[1].capitalize()} ({v[2]} km/h {v[3]}km)") for v in videos]

    routine_name, video_path, selected_speed = run_selection_ui(screen, routines, video_data, zwo_speed, pb_times=pb_times)

    if not all([routine_name, video_path, selected_speed]):
        pygame.quit()
        return

    show_status(screen, font, "Preparing workout...")
    routine_data = routines[routine_name]

    if isinstance(routine_data, dict) and "segments" in routine_data:
        routine_type = routine_data.get("type", "time")
        routine_segments = routine_data["segments"]
    else:
        routine_type = "time"
        routine_segments = routine_data

    show_status(screen, font, "Starting video and routine...")
    result = await exercise_routine(
        selected_speed,
        routine_type,
        [(d, selected_speed + inc) for d, inc in routine_segments],
        str(video_path)
    )

    if result:
        show_post_workout_stats()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    finally:
        pygame.quit()
--- End of RoutineSender.py ---

[File] RunRoutine.py
--- Start of RunRoutine.py ---
import asyncio
import os
import json
from datetime import datetime
from treadmill_control import TreadmillControl, parse_treadmill_data
from video_playback import play_video
from virtual_competitors import generate_competitors_with_profiles
from tcx_incremental import (
    start_tcx_file,
    start_new_lap,
    append_tcx_trackpoint,
    finalize_lap,
    finalize_tcx_file
)

def simulate_ghost_distance(speed_profile, elapsed_seconds):
    distance = 0.0
    for i in range(len(speed_profile)):
        t_start, speed = speed_profile[i]
        t_end = speed_profile[i + 1][0] if i + 1 < len(speed_profile) else float('inf')
        if elapsed_seconds < t_start:
            break
        duration = min(elapsed_seconds, t_end) - t_start
        distance += (speed * (duration / 3600))  # km/h * hours = km
        if elapsed_seconds < t_end:
            break
    return distance * 1000  # meters

def get_current_ghost_speed(speed_profile, elapsed_seconds):
    for i in range(len(speed_profile) - 1):
        t0, s0 = speed_profile[i]
        t1, s1 = speed_profile[i + 1]
        if t0 <= elapsed_seconds < t1:
            ratio = (elapsed_seconds - t0) / (t1 - t0)
            return s0 + ratio * (s1 - s0)
    return speed_profile[-1][1]

async def exercise_routine(initial_speed, routine_type, routine, video_path):
    def load_user_config(config_path='user_config.json'):
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except Exception:
            return {}

    shared_state = {"elapsed_time": 0.0, "distance": 0.0}
    treadmill = TreadmillControl()
    await treadmill.connect()
    await treadmill.request_control()

    speed_ratio_queue = asyncio.Queue(maxsize=1)
    await speed_ratio_queue.put(1.0)
    speed_queue = asyncio.Queue(maxsize=1)
    await speed_queue.put(initial_speed)
    distance_queue = asyncio.Queue(maxsize=1)
    await distance_queue.put(0.0)
    elapsed_time_queue = asyncio.Queue(maxsize=1)
    ghost_gap_queue = asyncio.Queue(maxsize=1)
    exit_signal = asyncio.Queue(maxsize=1)

    print("[INFO] Launching video playback...")
    video_task = asyncio.create_task(
        play_video(
            video_path,
            speed_ratio_queue,
            speed_queue,
            distance_queue,
            elapsed_time_queue,
            ghost_gap_queue,
            exit_signal
        )
    )

    await asyncio.sleep(2.0)
    print("[INFO] Sending FTMS 'Start or Resume' command...")
    await treadmill.start_or_resume()
    print("[INFO] Waiting for treadmill's 5-second countdown...")
    await asyncio.sleep(5)

    print(f"[INFO] Setting initial speed = {initial_speed:.2f} km/h and incline = 1.0%")
    await treadmill.set_speed(initial_speed)
    await treadmill.set_incline(1.0)

    start_time = datetime.utcnow()
    total_minutes = sum(duration for duration, _ in routine)
    total_distance_km = sum(inc * duration / 60 for duration, inc in routine)
    avg_speed = total_distance_km / (total_minutes / 60)

    user_config = load_user_config()
    pb_times = user_config.get("pb_times_minutes", {})
    goal_times = user_config.get("goal_times_minutes", {})
    pb_keys = set(map(int, pb_times.keys()))
    goal_keys = set(map(int, goal_times.keys()))
    available_keys = sorted(pb_keys | goal_keys)

    selected_key = None
    for key in reversed(available_keys):
        if total_distance_km >= key:
            selected_key = str(key)
            break

    ghost_runners = generate_competitors_with_profiles(total_minutes, avg_speed)

    for label, source in [("PB", pb_times), ("Goal", goal_times)]:
        minutes = source.get(selected_key)
        if minutes:
            distance_km = int(selected_key)
            speed = distance_km / (minutes / 60)
            ghost_runners.append({
                "base_name": f"{label} {selected_key}km",
                "speed_profile": [(0, speed)]
            })

    print(f"[DEBUG] Selected key: {selected_key}")
    print(f"[DEBUG] PB time: {pb_times.get(selected_key)} min")
    print(f"[DEBUG] Goal time: {goal_times.get(selected_key)} min")
    print(f"[DEBUG] Ghost runners: {[g['base_name'] for g in ghost_runners]}")

    start_tcx_file(start_time)

    loop = asyncio.get_event_loop()
    last_logged_distance = None
    last_distance = 0.0

    def callback(sender, data):
        nonlocal last_logged_distance, last_distance

        speed, distance, incline, elapsed_time = parse_treadmill_data(data)
        if incline is None: incline = 0.0
        if speed is None: speed = 0.0
        if distance is None: distance = 0.0
        if elapsed_time is None: elapsed_time = 0.0
        shared_state["elapsed_time"] = elapsed_time
        shared_state["distance"] = distance

        def safe_put(q, val):
            try: q.get_nowait()
            except asyncio.QueueEmpty: pass
            try: q.put_nowait(val)
            except asyncio.QueueFull: pass

        loop.call_soon_threadsafe(safe_put, speed_ratio_queue, speed / initial_speed if initial_speed > 0 else 1.0)
        loop.call_soon_threadsafe(safe_put, speed_queue, speed)
        loop.call_soon_threadsafe(safe_put, distance_queue, distance)
        loop.call_soon_threadsafe(safe_put, elapsed_time_queue, elapsed_time)

        timestamp = datetime.utcnow()
        append_tcx_trackpoint(timestamp, speed, distance, incline)
        last_distance = distance

        elapsed = (timestamp - start_time).total_seconds()
        user_distance_m = distance * 1000
        distance_rounded = round(user_distance_m, 1)

        if last_logged_distance != distance_rounded:
            last_logged_distance = distance_rounded
            ghost_gaps = {}
            for ghost in ghost_runners:
                ghost_distance_m = simulate_ghost_distance(ghost["speed_profile"], elapsed)
                current_speed = get_current_ghost_speed(ghost["speed_profile"], elapsed)
                ghost_name = f"{ghost['base_name']} ({current_speed:.1f} km/h)"
                gap = user_distance_m - ghost_distance_m
                ghost_gaps[ghost_name] = gap
            loop.call_soon_threadsafe(ghost_gap_queue.put_nowait, ghost_gaps)

    print("[INFO] Starting treadmill monitoring...")
    await treadmill.start_monitoring(callback)

    try:
        print("[INFO] Starting routine segments...")
        for idx, (duration, speed_increment) in enumerate(routine):
            print(f"[SEGMENT {idx}] Setting speed to {speed_increment:.2f} km/h for {duration:.1f} {'min' if routine_type == 'time' else 'km'}")
            await treadmill.set_speed(speed_increment)

            lap_start_time = datetime.utcnow()
            lap_start_distance = shared_state["distance"]
            start_new_lap(lap_start_time, lap_start_distance)

            if routine_type == "time":
                segment_start = shared_state["elapsed_time"]
                target = segment_start + duration * 60
                print(f"[SEGMENT] Time-based: {segment_start:.1f}s ‚Üí {target:.1f}s")
            else:
                segment_start = shared_state["distance"]
                target = segment_start + duration
                print(f"[SEGMENT] Distance-based: {segment_start:.2f}km ‚Üí {target:.2f}km")

            while True:
                await asyncio.sleep(0.2)
                current = shared_state["elapsed_time"] if routine_type == "time" else shared_state["distance"]
                if not exit_signal.empty():
                    print("[INFO] User exit detected.")
                    raise asyncio.CancelledError("User requested exit")
                if current >= target:
                    print("[SEGMENT] Segment complete.")
                    break

            lap_end_time = datetime.utcnow()
            lap_end_distance = shared_state["distance"]
            finalize_lap(lap_end_time, lap_end_distance)

    except asyncio.CancelledError:
        print("[INFO] Workout interrupted by user.")
    finally:
        print("[INFO] Cleaning up...")
        await video_task
        end_time = datetime.utcnow()
        final_distance = last_distance
        finalize_tcx_file()

        print("[INFO] Workout complete.")
        return {
            "start_time": start_time,
            "end_time": end_time,
            "final_distance": final_distance
        }
--- End of RunRoutine.py ---

[Folder] Simulation/
[Folder] TCX/
[Folder] __pycache__/
[Folder] assets/
[Folder] fonts/
[File] ghost_runner_hud.py
--- Start of ghost_runner_hud.py ---
import cv2
import numpy as np

class GhostRunnerHUD:
    def __init__(self, sprite_path='Animations/Runners.png', target_width=50, animation_speed=5):
        self.sprite_path = sprite_path
        self.target_width = target_width
        self.animation_speed = animation_speed
        self.frames = []
        self.frame_idx = 0
        self.frame_counter = 0
        self._load_and_process_sprites()

    def _convert_black_on_white_to_white_on_transparent(self, frame):
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        inverted = cv2.bitwise_not(gray)
        _, alpha = cv2.threshold(inverted, 30, 255, cv2.THRESH_BINARY)
        b = np.ones_like(alpha) * 255
        g = np.ones_like(alpha) * 255
        r = np.ones_like(alpha) * 255
        rgba = cv2.merge([b, g, r, alpha])
        return rgba

    def _resize_sprite(self, frame, target_width=None):
        if target_width is None:
            target_width = self.target_width
        h, w = frame.shape[:2]
        scale = target_width / w
        new_size = (target_width, int(h * scale))
        return cv2.resize(frame, new_size, interpolation=cv2.INTER_AREA)

    def _tint_sprite_red(self, sprite):
        tinted = sprite.copy()
        if sprite.shape[2] == 4:
            b, g, r, a = cv2.split(tinted)
            r = np.clip(r.astype(np.int32) + 100, 0, 255).astype(np.uint8)
            g = np.clip(g.astype(np.int32) * 0.3, 0, 255).astype(np.uint8)
            b = np.clip(b.astype(np.int32) * 0.3, 0, 255).astype(np.uint8)
            return cv2.merge([b, g, r, a])
        return tinted

    def _overlay_sprite(self, background, sprite, x, y):
        h, w = sprite.shape[:2]
        if y < 0 or y + h > background.shape[0] or x < 0 or x + w > background.shape[1]:
            return
        if sprite.shape[2] == 4:
            alpha_s = sprite[:, :, 3] / 255.0
            alpha_s = alpha_s[..., None]
            alpha_b = 1.0 - alpha_s
            for c in range(3):
                background[y:y+h, x:x+w, c] = (alpha_s[:, :, 0] * sprite[:, :, c] +
                                               alpha_b[:, :, 0] * background[y:y+h, x:x+w, c])
        else:
            background[y:y+h, x:x+w] = sprite

    def _load_and_process_sprites(self):
        img = cv2.imread(self.sprite_path, cv2.IMREAD_UNCHANGED)
        if img is None:
            raise FileNotFoundError(f"Could not load sprite image '{self.sprite_path}'")
        h, w = img.shape[:2]
        half_h, half_w = h // 2, w // 2
        center_crop_width = 205
        crop_x_start = half_w // 2 - center_crop_width // 2
        crop_x_end = crop_x_start + center_crop_width
        quadrants = [
            img[0:half_h, crop_x_start:crop_x_end],
            img[0:half_h, half_w + crop_x_start:half_w + crop_x_end],
            img[half_h:h, crop_x_start:crop_x_end],
            img[half_h:h, half_w + crop_x_start:half_w + crop_x_end]
        ]
        processed = []
        for f in quadrants:
            rgba = self._convert_black_on_white_to_white_on_transparent(f)
            resized = self._resize_sprite(rgba)
            processed.append(resized)
        self.frames = processed

    def draw_ghost_runners(self, frame, ghost_gaps):
        if not isinstance(ghost_gaps, dict):
            print("ghost_gaps is not a dictionary or is None")
            return

        # Split into left and right runners
        left_runners = []
        right_runners = []
        for name, gap in ghost_gaps.items():
            if name.startswith("PB") or name.startswith("Goal"):
                left_runners.append((name, gap))
            else:
                right_runners.append((name, gap))

        # Update animation frame
        self.frame_counter += 1
        if self.frame_counter % self.animation_speed == 0:
            self.frame_idx = (self.frame_idx + 1) % len(self.frames)

        base_sprite = self.frames[self.frame_idx]
        sprite_h, sprite_w = base_sprite.shape[:2]
        screen_h, screen_w = frame.shape[:2]

        def draw_group(runners, side):
            max_runners = 3
            selected = sorted(runners, reverse=True)[:max_runners]
            
            if side == "right":
                start_x = screen_w - (sprite_w * max_runners) - (5 * (max_runners - 1)) - 20
                base_y = screen_h - 30 - (len(selected) - 1) * 25 - sprite_h - 10
            else:
                start_x = 20
                base_y = screen_h - 60 - (len(selected) - 1) * 25 - sprite_h - 10

            for i, (name, gap) in enumerate(selected):
                try:
                    gap = float(gap)
                    if gap > 50 or gap < -400:
                        continue
                    ratio = max(0.0, min(1.0, 1 + (gap / 400.0)))
                    width = max(5, int(self.target_width * ratio))
                    sprite = self._resize_sprite(base_sprite, target_width=width)
                    if gap > 0:
                        sprite = self._tint_sprite_red(sprite)
                    x = start_x + i * (sprite.shape[1] + 5)
                    self._overlay_sprite(frame, sprite, x, base_y)


                except Exception as e:
                    print(f"Error processing ghost '{name}': {e}")


        draw_group(left_runners, "left")
        draw_group(right_runners, "right")
--- End of ghost_runner_hud.py ---

[File] list_directory.py
--- Start of list_directory.py ---
import os

# Define the file extensions to include
INCLUDED_EXTENSIONS = {'.json', '.py', '.css', '.js', '.html'}

def write_directory_contents(output_file, current_path, indent_level=0):
    indent = '    ' * indent_level
    try:
        entries = sorted(os.listdir(current_path))
    except PermissionError:
        output_file.write(f"{indent}[Permission Denied]: {current_path}\n")
        return

    for entry in entries:
        full_path = os.path.join(current_path, entry)
        if os.path.isdir(full_path):
            output_file.write(f"{indent}[Folder] {entry}/\n")
            write_directory_contents(output_file, full_path, indent_level + 1)
        elif os.path.isfile(full_path):
            _, ext = os.path.splitext(entry)
            if ext.lower() in INCLUDED_EXTENSIONS:
                output_file.write(f"{indent}[File] {entry}\n")
                try:
                    with open(full_path, 'r', encoding='utf-8', errors='replace') as file:
                        content = file.read()
                        output_file.write(f"{indent}--- Start of {entry} ---\n")
                        for line in content.splitlines():
                            output_file.write(f"{indent}{line}\n")
                        output_file.write(f"{indent}--- End of {entry} ---\n\n")
                except Exception as e:
                    output_file.write(f"{indent}[Error reading file]: {e}\n")

def main():
    output_filename = 'directory_contents.txt'
    with open(output_filename, 'w', encoding='utf-8') as output_file:
        start_path = os.getcwd()
        output_file.write(f"Directory structure and file contents of: {start_path}\n\n")
        write_directory_contents(output_file, start_path)

if __name__ == "__main__":
    main()
--- End of list_directory.py ---

[File] log_simulator.py
--- Start of log_simulator.py ---
import json
import asyncio
import os

async def simulate_from_log(callback, log_path=None):
    if log_path is None:
        base_dir = os.path.dirname(__file__)
        log_path = os.path.join(base_dir, "Simulation", "treadmill_log.json")

    try:
        with open(log_path, "r") as f:
            log_entries = json.load(f)
    except FileNotFoundError:
        print(f"[Sim] Log file not found at: {os.path.abspath(log_path)}")
        return

    for entry in log_entries:
        raw_bytes = bytes.fromhex(entry["raw"])
        #print(f"[Sim] Sending: {entry['timestamp']} raw={entry['raw']}")
        callback(None, raw_bytes)
        await asyncio.sleep(1)
--- End of log_simulator.py ---

[File] menu_ui.py
--- Start of menu_ui.py ---
import pygame
from pathlib import Path
import math
import os

# Colors
WHITE = (255, 255, 255)
BLACK = (20, 20, 20)
HIGHLIGHT = (50, 200, 255)
LIGHT_HIGHLIGHT = (80, 120, 160)
SHADOW = (10, 10, 10)
GRADIENT_START = (30, 30, 40)
GRADIENT_END = (10, 10, 20)

# Sizes
FONT_SIZE = 18
TITLE_FONT_SIZE = 12
THUMBNAIL_SIZE = (140, 100)
SPEED_THUMBNAIL_SIZE = (120, 15)
ITEM_SPACING = 160
CAROUSEL_Y_POSITIONS = [120, 280, 420]
START_BUTTON_Y = 500

# Load Roboto fonts
def load_fonts():
    fonts = {}
    fonts['regular'] = pygame.font.Font("fonts/Roboto-Regular.ttf", FONT_SIZE)
    fonts['bold'] = pygame.font.Font("fonts/Roboto-Bold.ttf", FONT_SIZE)
    fonts['title'] = pygame.font.Font("fonts/Roboto-Bold.ttf", TITLE_FONT_SIZE)
    fonts['start'] = pygame.font.Font("fonts/Roboto-Bold.ttf", 24)
    return fonts

def load_thumbnail(path, size=THUMBNAIL_SIZE):
    p = Path(path)
    if not p.exists():
        return None
    try:
        img = pygame.image.load(str(p)).convert_alpha()
        return pygame.transform.smoothscale(img, size)
    except Exception:
        return None

def draw_vertical_gradient(surface, color_start, color_end):
    height = surface.get_height()
    for y in range(height):
        ratio = y / height
        r = int(color_start[0] * (1 - ratio) + color_end[0] * ratio)
        g = int(color_start[1] * (1 - ratio) + color_end[1] * ratio)
        b = int(color_start[2] * (1 - ratio) + color_end[2] * ratio)
        pygame.draw.line(surface, (r, g, b), (0, y), (surface.get_width(), y))

def run_selection_ui(screen, routines, videos, start_speed=8.5, pb_times=None):
    import pygame
    from pathlib import Path
    import os

    # Colors
    WHITE = (255, 255, 255)
    BLACK = (20, 20, 20)
    HIGHLIGHT = (50, 200, 255)
    LIGHT_HIGHLIGHT = (80, 120, 160)
    SHADOW = (10, 10, 10)
    GOLD = (255, 215, 0)

    # Sizes
    FONT_SIZE = 18
    TITLE_FONT_SIZE = 12
    THUMBNAIL_SIZE = (140, 100)
    SPEED_THUMBNAIL_SIZE = (120, 15)
    ITEM_SPACING = 160
    CAROUSEL_Y_POSITIONS = [120, 280, 420]
    START_BUTTON_Y = 500

    def load_fonts():
        fonts = {}
        fonts['regular'] = pygame.font.Font("fonts/Roboto-Regular.ttf", FONT_SIZE)
        fonts['bold'] = pygame.font.Font("fonts/Roboto-Bold.ttf", FONT_SIZE)
        fonts['title'] = pygame.font.Font("fonts/Roboto-Bold.ttf", TITLE_FONT_SIZE)
        fonts['start'] = pygame.font.Font("fonts/Roboto-Bold.ttf", 24)
        return fonts

    def load_thumbnail(path, size=THUMBNAIL_SIZE):
        p = Path(path)
        if not p.exists():
            return None
        try:
            img = pygame.image.load(str(p)).convert_alpha()
            return pygame.transform.smoothscale(img, size)
        except Exception:
            return None

    fonts = load_fonts()
    pb_times = pb_times or {}

    routine_names = list(routines.keys())
    routine_thumbs = [load_thumbnail(f"routines/{name}.png") for name in routine_names]

    video_files = [v[0] for v in videos]
    video_labels = [v[1] for v in videos]
    video_thumbs = [load_thumbnail(f"videos/{Path(v[0]).with_suffix('.png').name}") for v in videos]

    speeds = [round(x * 0.1, 1) for x in range(10, 201)]
    start_speed = max(1.0, min(start_speed, 20.0))
    speed_idx = min(range(len(speeds)), key=lambda i: abs(speeds[i] - start_speed))

    selections = [0, 0, speed_idx]
    offsets = [0, 0, max(0, speed_idx - 2)]
    focused = 0

    clock = pygame.time.Clock()
    running = True

    background_path = "assets/background.jpg"
    background_img = pygame.image.load(background_path).convert()
    background_img = pygame.transform.scale(background_img, screen.get_size())

    while running:
        screen.blit(background_img, (0, 0))
        screen_width = screen.get_width()

        for carousel_i in range(3):
            y = CAROUSEL_Y_POSITIONS[carousel_i]
            selected_idx = selections[carousel_i]
            offset = offsets[carousel_i]

            if carousel_i == 0:
                items = routine_names
                thumbs = routine_thumbs
                titles = routine_names
                thumb_size = THUMBNAIL_SIZE
            elif carousel_i == 1:
                items = video_labels
                thumbs = video_thumbs
                titles = video_labels
                thumb_size = THUMBNAIL_SIZE
            else:
                items = [f"{s:.1f} km/h" for s in speeds]
                thumbs = [None] * len(items)
                titles = items
                thumb_size = SPEED_THUMBNAIL_SIZE

            visible_range = range(offset, min(offset + 5, len(items)))
            total_width = (len(visible_range) - 1) * ITEM_SPACING
            start_x = (screen_width - total_width) // 2

            for i, idx in enumerate(visible_range):
                x = start_x + i * ITEM_SPACING
                is_selected = (idx == selected_idx)
                is_focused = (carousel_i == focused)

                label_text = titles[idx]
                font_to_use = fonts['bold'] if is_selected else fonts['regular']
                label_surf = font_to_use.render(label_text, True, WHITE)
                label_rect = label_surf.get_rect(center=(x, y + thumb_size[1] // 2 + 25))

                if is_selected:
                    shadow_rect = pygame.Rect(
                        x - thumb_size[0] // 2 - 15,
                        y - thumb_size[1] // 2 - 15,
                        thumb_size[0] + 30,
                        thumb_size[1] + 70
                    )
                    shadow_surf = pygame.Surface(shadow_rect.size, pygame.SRCALPHA)
                    shadow_surf.fill((*SHADOW, 100))
                    screen.blit(shadow_surf, shadow_rect.topleft)

                    highlight_color = HIGHLIGHT if is_focused else LIGHT_HIGHLIGHT
                    highlight_surf = pygame.Surface((thumb_size[0] + 20, thumb_size[1] + 60), pygame.SRCALPHA)
                    alpha = 180 if is_focused else 100
                    highlight_surf.fill((*highlight_color, alpha))
                    screen.blit(highlight_surf, (x - thumb_size[0] // 2 - 10, y - thumb_size[1] // 2 - 10))

                # PB Highlighting
                if carousel_i == 2:
                    selected_routine = routines[routine_names[selections[0]]]
                    segments = selected_routine["segments"] if isinstance(selected_routine, dict) and "segments" in selected_routine else selected_routine
                    total_duration = sum(d for d, _ in segments)
                    increments = [inc for _, inc in segments]
                    avg_increment = sum(increments) / len(increments) if increments else 0

                    for dist_str, pb_time in pb_times.items():
                        try:
                            dist_km = float(dist_str)
                            pb_speed = dist_km / (pb_time / 60)
                            import math
                            base_speed = math.ceil((pb_speed - avg_increment) * 10) / 10

                            if abs(speeds[idx] - base_speed) < 0.1:
                                pygame.draw.circle(screen, GOLD, (x, y), thumb_size[1] // 2 + 10, 3)
                                label = fonts['title'].render(f"üèÖ {dist_str}k PB", True, GOLD)
                                screen.blit(label, label.get_rect(center=(x, y - 25)))
                        except Exception:
                            continue

                if carousel_i != 2 and thumbs[idx]:
                    thumb_rect = thumbs[idx].get_rect(center=(x, y))
                    screen.blit(thumbs[idx], thumb_rect)
                elif carousel_i != 2:
                    rect = pygame.Rect(x - thumb_size[0] // 2, y - thumb_size[1] // 2,
                                       thumb_size[0], thumb_size[1])
                    pygame.draw.rect(screen, WHITE, rect, 2)

                screen.blit(label_surf, label_rect)

        # START button
        start_rect = pygame.Rect(screen_width // 2 - 120, START_BUTTON_Y, 240, 60)
        shadow_surf = pygame.Surface((start_rect.width + 10, start_rect.height + 10), pygame.SRCALPHA)
        shadow_surf.fill((*SHADOW, 150))
        screen.blit(shadow_surf, (start_rect.x + 5, start_rect.y + 5))

        if focused == 3:
            pygame.draw.rect(screen, HIGHLIGHT, start_rect, border_radius=8)
            start_text = fonts['start'].render("START", True, BLACK)
        else:
            pygame.draw.rect(screen, WHITE, start_rect, 3, border_radius=8)
            start_text = fonts['start'].render("START", True, WHITE)

        screen.blit(start_text, start_text.get_rect(center=start_rect.center))
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return None, None, None
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    return None, None, None
                elif event.key == pygame.K_DOWN:
                    focused = (focused + 1) % 4
                elif event.key == pygame.K_UP:
                    focused = (focused - 1) % 4
                elif event.key == pygame.K_RIGHT:
                    if focused < 3:
                        max_idx = (
                            len(routine_names) - 1 if focused == 0 else
                            len(video_labels) - 1 if focused == 1 else
                            len(speeds) - 1
                        )
                        if selections[focused] < max_idx:
                            selections[focused] += 1
                            if selections[focused] >= offsets[focused] + 5:
                                offsets[focused] += 1
                elif event.key == pygame.K_LEFT:
                    if focused < 3 and selections[focused] > 0:
                        selections[focused] -= 1
                        if selections[focused] < offsets[focused]:
                            offsets[focused] = max(0, offsets[focused] - 1)
                elif event.key == pygame.K_RETURN and focused == 3:
                    routine = routine_names[selections[0]]
                    video_file = video_files[selections[1]]
                    speed = speeds[selections[2]]
                    return routine, os.path.join('videos', video_file), speed

        clock.tick(30)
--- End of menu_ui.py ---

[Folder] music/
[File] post_workout_stats.py
--- Start of post_workout_stats.py ---
import pygame
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
import os
import json

TCX_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), 'TCX'))
CONFIG_FILE = os.path.abspath(os.path.join(os.path.dirname(__file__), 'user_config.json'))
PB_DISTANCES = [1, 3, 5, 10, 21]  # in km

def find_latest_tcx_file(directory):
    try:
        tcx_files = [os.path.join(directory, f) for f in os.listdir(directory) if f.endswith('.tcx')]
        return max(tcx_files, key=os.path.getmtime) if tcx_files else None
    except FileNotFoundError:
        print(f"ERROR: TCX directory not found: {directory}")
        return None

def parse_tcx_trackpoints(tcx_filename):
    tree = ET.parse(tcx_filename)
    root = tree.getroot()
    ns = {'ns': 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2'}
    trackpoints = root.findall('.//ns:Trackpoint', ns)

    points = []
    for tp in trackpoints:
        dist_elem = tp.find('ns:DistanceMeters', ns)
        time_elem = tp.find('ns:Time', ns)
        if dist_elem is not None and time_elem is not None:
            dist_km = float(dist_elem.text) / 1000
            timestamp = datetime.fromisoformat(time_elem.text.replace("Z", "+00:00"))
            points.append((timestamp, dist_km))
    return points

def load_user_config():
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except Exception:
        return {"pb_times_minutes": {}}

def save_user_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

def check_for_pbs(trackpoints, user_config):
    pb_updates = {}
    pb_times = user_config.get("pb_times_minutes", {})
    reached = set()

    for i in range(1, len(trackpoints)):
        t0, d0 = trackpoints[0]
        ti, di = trackpoints[i]

        for target_km in PB_DISTANCES:
            if target_km in reached:
                continue
            if di >= target_km:
                elapsed = (ti - t0).total_seconds() / 60  # minutes
                prev_pb = pb_times.get(str(target_km), float('inf'))
                if elapsed < prev_pb:
                    print("new PB")
                    pb_times[str(target_km)] = elapsed
                    pb_updates[target_km] = elapsed
                reached.add(target_km)

    return pb_updates

def show_post_workout_stats():
    print("loading workout stats")
    pygame.init()
    screen = pygame.display.set_mode((800, 600), pygame.FULLSCREEN)
    pygame.display.set_caption("Workout Summary")
    font = pygame.font.Font(None, 48)
    small_font = pygame.font.Font(None, 36)

    latest_tcx = find_latest_tcx_file(TCX_DIR)
    if not latest_tcx:
        lines = ["No TCX files found.", "", "Press any key to exit..."]
    else:
        points = parse_tcx_trackpoints(latest_tcx)
        if not points:
            lines = ["No valid data in TCX.", "", "Press any key to exit..."]
        else:
            start_time = points[0][0]
            end_time = points[-1][0]
            total_distance_km = points[-1][1]
            duration = end_time - start_time
            total_minutes = duration.total_seconds() / 60
            avg_pace = total_minutes / total_distance_km if total_distance_km > 0 else 0

            # Load config and check PBs
            config = load_user_config()
            pb_updates = check_for_pbs(points, config)
            if pb_updates:
                save_user_config(config)

            # Summary + PB lines
            lines = [
                "Workout Summary",
                f"Duration: {str(timedelta(seconds=int(duration.total_seconds())))}",
                f"Distance: {total_distance_km:.2f} km",
                f"Avg Pace: {avg_pace:.2f} min/km",
                ""
            ]
            if pb_updates:
                lines.append("üèÜ New PBs:")
                for dist in sorted(pb_updates.keys()):
                    lines.append(f"  {dist} km: {pb_updates[dist]:.1f} min")
            else:
                lines.append("No PBs this time. Keep going!")

            lines.append("")
            lines.append("Press any key to exit...")

    # Render screen
    screen.fill((0, 0, 0))
    y = 80
    for line in lines:
        text = font.render(line, True, (255, 255, 255)) if line else small_font.render(" ", True, (255, 255, 255))
        rect = text.get_rect(center=(screen.get_width() // 2, y))
        screen.blit(text, rect)
        y += 60

    pygame.display.flip()

    # Wait for any key
    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN or event.type == pygame.QUIT:
                waiting = False
                break
    pygame.quit()
--- End of post_workout_stats.py ---

[Folder] routines/
    [File] generate_zwo_thumbnail.py
    --- Start of generate_zwo_thumbnail.py ---
    import os
    import sys
    import json
    import xml.etree.ElementTree as ET
    import matplotlib.pyplot as plt
    from pathlib import Path
    import re
    
    def parse_zwo(file_path):
        tree = ET.parse(file_path)
        root = tree.getroot()
    
        # Extract name
        routine_name_elem = root.find('name')
        routine_name = routine_name_elem.text.strip() if routine_name_elem is not None else file_path.stem
    
        # Extract type
        duration_type_elem = root.find('durationType')
        routine_type = duration_type_elem.text.strip().lower() if duration_type_elem is not None else "time"
    
        workout = root.find('workout')
        if workout is None:
            raise ValueError("No <workout> element found.")
    
        segments = []
        for elem in workout:
            tag = elem.tag
            attrib = elem.attrib
            if tag in ['Warmup', 'Cooldown']:
                duration = float(attrib.get('Duration', 0))
                power_low = float(attrib.get('PowerLow', 0))
                power_high = float(attrib.get('PowerHigh', 0))
                segments.append({
                    'type': tag,
                    'duration': duration,
                    'power_low': power_low,
                    'power_high': power_high
                })
            elif tag == 'IntervalsT':
                repeat = int(attrib.get('Repeat', 1))
                on_duration = float(attrib.get('OnDuration', 0))
                off_duration = float(attrib.get('OffDuration', 0))
                on_power = float(attrib.get('OnPower', 0))
                off_power = float(attrib.get('OffPower', 0))
                for _ in range(repeat):
                    segments.append({'type': 'Interval On', 'duration': on_duration, 'power': on_power})
                    segments.append({'type': 'Interval Off', 'duration': off_duration, 'power': off_power})
    
        return segments, routine_name, routine_type
    
    
    def parse_json_config(config):
        segments = []
        for duration, power in config:
            segments.append({
                'type': 'Interval',
                'duration': duration * 60,
                'power': power
            })
        return segments
    
    
    def plot_workout(segments, output_file, routine_type="time"):
        current_time = 0
        colors = []
    
        for seg in segments:
            duration = seg['duration']
            if seg['type'] in ['Warmup', 'Cooldown']:
                power = (seg['power_low'] + seg['power_high']) / 2
            else:
                power = seg['power']
    
            if power < 0.9:
                color = 'green'
            elif power < 1.0:
                color = 'yellow'
            elif power < 1.1:
                color = 'orange'
            else:
                color = 'red'
    
            colors.append((current_time, current_time + duration, power, color))
            current_time += duration
    
        plt.figure(figsize=(10, 4))
        for start, end, power, color in colors:
            plt.fill_between([start, end], 0, power, step='post', color=color, alpha=0.7)
    
        # Labels
        plt.xlabel('Time (s)')
        plt.ylabel('Power (FTP)')
        plt.title('Workout Chart')
        plt.grid(True)
    
        # Add T or D label in top-right
        label = "T" if routine_type == "time" else "D"
        plt.text(0.98, 0.95, label, transform=plt.gca().transAxes,
                 fontsize=30, fontweight='bold', color='gray',
                 ha='right', va='top', alpha=0.5)
    
        plt.tight_layout()
        plt.savefig(output_file)
        plt.close()
    
    
    def generate_thumbnail(zwo_path):
        zwo_file = Path(zwo_path)
        if not zwo_file.is_file() or zwo_file.suffix.lower() != '.zwo':
            print(f"Invalid .zwo file: {zwo_path}")
            return
    
        try:
            segments, routine_name, routine_type = parse_zwo(zwo_file)
        except Exception as e:
            print(f"Failed to parse {zwo_file.name}: {e}")
            return
    
        safe_name = re.sub(r'[^A-Za-z0-9_\- ]+', '', routine_name).strip()
        thumbnail_path = Path(f"{safe_name}.png")
    
        if thumbnail_path.exists():
            print(f"Thumbnail already exists: {thumbnail_path}")
            return
    
        try:
            plot_workout(segments, thumbnail_path, routine_type)
            print(f"Thumbnail created: {thumbnail_path}")
        except Exception as e:
            print(f"Error generating thumbnail for {zwo_file.name}: {e}")
    
    
    def generate_thumbnail_from_config(config, name, routine_type):
        safe_name = re.sub(r'[^A-Za-z0-9_\- ]+', '', name).strip()
        thumbnail_path = Path(f"{safe_name}.png")
    
        if thumbnail_path.exists():
            print(f"Thumbnail already exists: {thumbnail_path}")
            return
    
        try:
            segments = parse_json_config(config)
            plot_workout(segments, thumbnail_path, routine_type)
            print(f"Thumbnail created: {thumbnail_path}")
        except Exception as e:
            print(f"Error processing {name}: {e}")
    
    
    def process_directory(directory):
        dir_path = Path(directory)
        for zwo_file in dir_path.glob('*.zwo'):
            generate_thumbnail(zwo_file)
    
    
    def load_routines_json():
        routines_path = Path(__file__).parent.parent / "Routines.json"
        if not routines_path.exists():
            print(f"Routines.json not found at {routines_path}")
            return {}
    
        try:
            with open(routines_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"Error reading Routines.json: {e}")
            return {}
    
    
    if __name__ == "__main__":
        if len(sys.argv) > 1:
            generate_thumbnail(sys.argv[1])
        else:
            process_directory('.')
    
            # Load and process JSON routines from ../Routines.json
            routines = load_routines_json()
            for name, conf in routines.items():
                routine_type = conf.get("type", "time")
                segments = conf.get("segments", [])
                if segments:
                    generate_thumbnail_from_config(segments, name, routine_type)
    --- End of generate_zwo_thumbnail.py ---

[File] routines.json
--- Start of routines.json ---
{
    "Basic_pillars": {
        "type": "time",
        "segments": [
            [5, 0],
            [5, 0.5],
            [4, 0],
            [4, 1.0],
            [3, 0],
            [3, 1.5],
            [2, 0],
            [2, 2.0],
            [1, 0],
            [1, 2.5]
        ]
    },
    "long_pillars": {
        "type": "time",
        "segments": [
            [6, 0],
            [6, 0.5],
            [5, 0],
            [5, 1.0],
            [4, 0],
            [4, 1.5],
            [3, 0],
            [3, 2.0],
            [2, 0],
            [2, 2.5],
            [1, 0],
            [2, 3]
        ]
    },
    "Pillars_Buffer": {
        "type": "time",
        "segments": [
            [3.5, 0.5],
            [5, 0.0],
            [5, 0.5],
            [4, 0],
            [4, 1.0],
            [3, 0],
            [3, 1.5],
            [2, 0],
            [2, 2.0],
            [1, 0],
            [1, 2.5]
        ]
    },
    "Testtime": {
        "type": "time",
        "segments": [
            [0.5, 0.5],
            [0.5, 0.0],
            [0.5, 0.5],
            [0.5, 0],
            [1, 1.0],
            [3, 0],
            [3, 1.5],
            [2, 0],
            [2, 2.0],
            [1, 0],
            [1, 2.5]
        ]
    },
    "Testdist": {
        "type": "distance",
        "segments": [
            [0.1, 0.5],
            [0.1, 0.0],
            [0.5, 0.5],
            [0.5, 0],
            [1, 1.0],
            [3, 0],
            [3, 1.5],
            [2, 0],
            [2, 2.0],
            [1, 0],
            [1, 2.5]
        ]
    },
    "5k": {
        "type": "distance",
        "segments": [
            [0.2, 0.5],
            [0.1, 0.0],
            [0.2, 0.5]
        ]
    },
    "33mins": {
        "type": "time",
        "segments": [
            [2, 0.5],
            [29, 0.0],
            [2, 0.5]
        ]
    },
    "10k": {
        "type": "distance",
        "segments": [
            [10, 0]
        ]
    },
    "3k": {
        "type": "distance",
        "segments": [
            [3, 0]
        ]
    }
    
}
--- End of routines.json ---

[File] tcx_incremental.py
--- Start of tcx_incremental.py ---
import os
from datetime import datetime
from typing import Optional

from xml.sax.saxutils import escape

NS_TCX = "http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2"
NS_TPX = "http://www.garmin.com/xmlschemas/ActivityExtension/v2"

tcx_filename = None
track_file = None
lap_start_time = None
lap_start_distance = 0.0
lap_index = 0
gps_track = []  # List of (distance_m, lat, lon)

def load_gpx_track(gpx_path):
    import xml.etree.ElementTree as ET
    tree = ET.parse(gpx_path)
    root = tree.getroot()
    ns = {'default': 'http://www.topografix.com/GPX/1/1'}
    trkpts = root.findall(".//default:trkpt", ns)

    track = []
    last_lat = last_lon = None
    total_distance = 0.0

    def haversine(lat1, lon1, lat2, lon2):
        from math import radians, sin, cos, sqrt, atan2
        R = 6371000  # Earth radius in meters
        dlat = radians(lat2 - lat1)
        dlon = radians(lon2 - lon1)
        a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
        return R * 2 * atan2(sqrt(a), sqrt(1 - a))

    for pt in trkpts:
        lat = float(pt.attrib['lat'])
        lon = float(pt.attrib['lon'])
        if last_lat is not None:
            total_distance += haversine(last_lat, last_lon, lat, lon)
        track.append((total_distance, lat, lon))
        last_lat, last_lon = lat, lon

    return track

def interpolate_gps(distance_m):
    if not gps_track or distance_m < gps_track[0][0] or distance_m > gps_track[-1][0]:
        return None, None
    for i in range(len(gps_track) - 1):
        d0, lat0, lon0 = gps_track[i]
        d1, lat1, lon1 = gps_track[i + 1]
        if d0 <= distance_m <= d1:
            ratio = (distance_m - d0) / (d1 - d0)
            lat = lat0 + ratio * (lat1 - lat0)
            lon = lon0 + ratio * (lon1 - lon0)
            return lat, lon
    return gps_track[-1][1], gps_track[-1][2]

def start_tcx_file(start_time: datetime, gpx_path: Optional[str] = None):
    global tcx_filename, track_file, lap_index, gps_track

    os.makedirs("TCX", exist_ok=True)
    tcx_filename = f"TCX/workout_{start_time.strftime('%Y-%m-%d_%H-%M-%S')}.tcx"
    lap_index = 0

    if gpx_path and os.path.exists(gpx_path):
        gps_track = load_gpx_track(gpx_path)

    with open(tcx_filename, 'w', encoding='utf-8') as f:
        f.write(f'''<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xmlns="{NS_TCX}" xmlns:ns3="{NS_TPX}">
  <Activities>
    <Activity Sport="VirtualRun">
      <Id>{start_time.isoformat()}</Id>
''')

    track_file = open(tcx_filename, 'a', encoding='utf-8')

def start_new_lap(start_time: datetime, start_distance_km: float):
    global track_file, lap_start_time, lap_start_distance, lap_index
    lap_start_time = start_time
    lap_start_distance = start_distance_km
    lap_index += 1

    track_file.write(f'''      <Lap StartTime="{start_time.isoformat()}">
        <TotalTimeSeconds>0</TotalTimeSeconds>
        <DistanceMeters>0</DistanceMeters>
        <Calories>0</Calories>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>
''')

def append_tcx_trackpoint(timestamp: datetime, speed_kmh: float, distance_km: float, incline_percent: float):
    global track_file

    time_iso = timestamp.isoformat()
    speed_mps = speed_kmh / 3.6
    dist_m = distance_km * 1000
    lat, lon = interpolate_gps(dist_m)

    track_file.write(f'''          <Trackpoint>
            <Time>{time_iso}</Time>
''')
    if lat is not None and lon is not None:
        track_file.write(f'''            <Position>
              <LatitudeDegrees>{lat:.6f}</LatitudeDegrees>
              <LongitudeDegrees>{lon:.6f}</LongitudeDegrees>
            </Position>
''')
    track_file.write(f'''            <DistanceMeters>{dist_m:.2f}</DistanceMeters>
            <Extensions>
              <ns3:TPX>
                <ns3:Speed>{speed_mps:.3f}</ns3:Speed>
                <ns3:Incline>{incline_percent:.2f}</ns3:Incline>
              </ns3:TPX>
            </Extensions>
          </Trackpoint>
''')

def finalize_lap(end_time: datetime, end_distance_km: float):
    global track_file, lap_start_time, lap_start_distance

    total_time = (end_time - lap_start_time).total_seconds()
    total_distance_m = (end_distance_km - lap_start_distance) * 1000

    track_file.write(f'''        </Track>
        <TotalTimeSeconds>{total_time:.1f}</TotalTimeSeconds>
        <DistanceMeters>{total_distance_m:.1f}</DistanceMeters>
      </Lap>
''')

def finalize_tcx_file():
    global track_file

    track_file.write(f'''    </Activity>
  </Activities>
</TrainingCenterDatabase>
''')
    track_file.close()
    print(f"‚úÖ TCX file written: {tcx_filename}")
--- End of tcx_incremental.py ---

[File] tcx_postprocess.py
--- Start of tcx_postprocess.py ---
import xml.etree.ElementTree as ET
from datetime import datetime
from geopy.distance import geodesic
import os

GPX_NS = {'gpx': 'http://www.topografix.com/GPX/1/1'}
TCX_NS = {'tcx': 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2'}
ET.register_namespace('', TCX_NS['tcx'])

def load_gpx_route_with_distances(gpx_file):
    tree = ET.parse(gpx_file)
    root = tree.getroot()

    route = []
    prev_point = None
    total_dist = 0.0

    for trkpt in root.findall('.//gpx:trkpt', GPX_NS):
        lat = float(trkpt.attrib['lat'])
        lon = float(trkpt.attrib['lon'])
        ele_elem = trkpt.find('gpx:ele', GPX_NS)
        ele = float(ele_elem.text) if ele_elem is not None else 0.0
        point = (lat, lon)

        if prev_point is not None:
            seg_dist = geodesic(prev_point, point).meters
            total_dist += seg_dist
        route.append({'lat': lat, 'lon': lon, 'ele': ele, 'cum_dist': total_dist})
        prev_point = point

    return route

def interpolate_route_point(route, target_dist):
    """
    Given a cumulative distance, interpolate lat, lon, ele along the route.
    """
    for i in range(1, len(route)):
        if route[i]['cum_dist'] >= target_dist:
            r0 = route[i - 1]
            r1 = route[i]
            dist_diff = r1['cum_dist'] - r0['cum_dist']
            if dist_diff == 0:
                frac = 0
            else:
                frac = (target_dist - r0['cum_dist']) / dist_diff

            lat = r0['lat'] + frac * (r1['lat'] - r0['lat'])
            lon = r0['lon'] + frac * (r1['lon'] - r0['lon'])
            ele = r0['ele'] + frac * (r1['ele'] - r0['ele'])
            return lat, lon, ele

    # If target_dist beyond route end, return last point
    return route[-1]['lat'], route[-1]['lon'], route[-1]['ele']

def post_process_tcx_with_gpx(tcx_file_path, gpx_file_path, output_file_path=None):
    if output_file_path is None:
        output_file_path = tcx_file_path  # overwrite by default

    print(f"[INFO] Loading GPX route from {gpx_file_path}...")
    route = load_gpx_route_with_distances(gpx_file_path)

    print(f"[INFO] Parsing TCX file {tcx_file_path}...")
    tree = ET.parse(tcx_file_path)
    root = tree.getroot()

    trackpoints = root.findall('.//tcx:Trackpoint', TCX_NS)
    print(f"[INFO] Found {len(trackpoints)} trackpoints in TCX.")

    updated_count = 0
    for tp in trackpoints:
        dist_elem = tp.find('tcx:DistanceMeters', TCX_NS)
        if dist_elem is None:
            continue
        try:
            dist_m = float(dist_elem.text)
        except Exception:
            continue

        lat, lon, ele = interpolate_route_point(route, dist_m)

        # Find or create Position element
        pos_elem = tp.find('tcx:Position', TCX_NS)
        if pos_elem is None:
            pos_elem = ET.SubElement(tp, f"{{{TCX_NS['tcx']}}}Position")

        lat_elem = pos_elem.find('tcx:LatitudeDegrees', TCX_NS)
        if lat_elem is None:
            lat_elem = ET.SubElement(pos_elem, f"{{{TCX_NS['tcx']}}}LatitudeDegrees")
        lat_elem.text = f"{lat:.6f}"

        lon_elem = pos_elem.find('tcx:LongitudeDegrees', TCX_NS)
        if lon_elem is None:
            lon_elem = ET.SubElement(pos_elem, f"{{{TCX_NS['tcx']}}}LongitudeDegrees")
        lon_elem.text = f"{lon:.6f}"

        # Find or create AltitudeMeters
        alt_elem = tp.find('tcx:AltitudeMeters', TCX_NS)
        if alt_elem is None:
            alt_elem = ET.SubElement(tp, f"{{{TCX_NS['tcx']}}}AltitudeMeters")
        alt_elem.text = f"{ele:.1f}"

        updated_count += 1

    print(f"[INFO] Updated {updated_count} trackpoints with GPS data.")

    tree.write(output_file_path, encoding='utf-8', xml_declaration=True)
    print(f"[INFO] Saved enriched TCX to {output_file_path}")
--- End of tcx_postprocess.py ---

[File] treadmill_control.py
--- Start of treadmill_control.py ---
# treadmill_control.py

import asyncio
import platform
import time
from bleak import BleakScanner, BleakClient
from log_simulator import simulate_from_log  # only used when testing

ftms_service_uuid = "00001826-0000-1000-8000-00805f9b34fb"
control_point_uuid = "00002AD9-0000-1000-8000-00805f9b34fb"
treadmill_data_uuid = "00002ACD-0000-1000-8000-00805f9b34fb"

class TreadmillControl:
    def __init__(self, testing=None, log_path="treadmill_log.json"):
        self.client = None
        self.testing = platform.system() == "Windows" if testing is None else testing
        self.log_path = log_path
        self.current_speed = 0.0
        self.start_time = None

    async def connect(self, target_name=None, target_address=None):
        if self.testing:
            print("Simulated connection to treadmill.")
            self.client = "SimulatedClient"
            return

        for attempt in range(6):
            try:
                print(f"BLE connection attempt {attempt + 1}")
                devices = await BleakScanner.discover(return_adv=True)

                treadmill = None
                for device, adv_data in devices.values():
                    print(f"- {device.name or 'Unknown'} ({device.address})")

                    if ftms_service_uuid in adv_data.service_uuids:
                        treadmill = device
                        print("Found FTMS treadmill.")
                        break
                    if target_name and device.name == target_name:
                        treadmill = device
                        print(f"Matched treadmill by name: {target_name}")
                        break
                    if target_address and device.address.lower() == target_address.lower():
                        treadmill = device
                        print(f"Matched treadmill by address: {target_address}")
                        break

                if treadmill:
                    self.client = BleakClient(treadmill.address)
                    await self.client.connect()
                    print(f"Connected to {treadmill.name or 'Unknown'} ({treadmill.address})")
                    return

                raise Exception("Treadmill not found.")
            except Exception as e:
                print(f"Attempt {attempt + 1} failed: {e}")
                await asyncio.sleep(2)

        raise Exception("Failed to connect after 6 attempts.")

    async def disconnect(self):
        if self.testing:
            print("Simulated disconnection from treadmill.")
            self.client = None
            return
        if self.client:
            await self.client.disconnect()

    async def request_control(self):
        if self.testing:
            print("Simulated control request.")
            return
        await self.client.write_gatt_char(control_point_uuid, bytearray([0x00]))
        await self.wait_for_response()

    async def set_speed(self, speed_kmh):
        self.current_speed = speed_kmh
        if self.testing:
            speed_mph = round(speed_kmh / 1.59, 2)
            print(f"Simulated setting speed to {speed_kmh:.2f} km/h ({speed_mph:.2f} mph)")
            return
        speed_mph = round(speed_kmh / 1.59, 2)
        speed_value = int(speed_mph * 100).to_bytes(2, byteorder='little')
        await self.client.write_gatt_char(control_point_uuid, bytearray([0x02]) + speed_value)
        print(f"Set speed to {speed_kmh:.2f} km/h ({speed_mph:.2f} mph)")
        await self.wait_for_response()

    async def set_incline(self, incline):
        if self.testing:
            print(f"Simulated setting incline to {incline:.1f} %")
            return
        incline_value = int(incline * 10).to_bytes(2, byteorder='little', signed=True)
        await self.client.write_gatt_char(control_point_uuid, bytearray([0x03]) + incline_value)
        print(f"Set incline to {incline:.1f} %")
        await self.wait_for_response()

    async def wait_for_response(self):
        if self.testing:
            print("Simulated waiting for response.")
            return

        def handle_response(sender, data):
            op_code = data[0]
            request_op_code = data[1]
            result_code = data[2]
            if result_code == 0x01:
                print(f"Operation {request_op_code} succeeded")
            else:
                print(f"Operation {request_op_code} failed with result code {result_code}")

        await self.client.start_notify(control_point_uuid, handle_response)
        await asyncio.sleep(1)
        await self.client.stop_notify(control_point_uuid)

    async def start_monitoring(self, callback):
        if self.testing:
            print("Simulated start monitoring from log.")
            asyncio.create_task(simulate_from_log(callback, self.log_path))
            return

        if self.client:
            await self.client.start_notify(treadmill_data_uuid, callback)

    async def stop_monitoring(self):
        if self.testing:
            print("Simulated stop monitoring.")
            return
        if self.client:
            await self.client.stop_notify(treadmill_data_uuid)

    async def increase_speed(self):
        await self.set_speed(self.current_speed + 0.5)

    async def decrease_speed(self):
        await self.set_speed(self.current_speed - 0.5)

    async def start_or_resume(self):
            if self.testing:
                print("Simulated FTMS start/resume command.")
                return
            await self.client.write_gatt_char(control_point_uuid, bytearray([0x07]))
            await self.wait_for_response()

def parse_treadmill_data(data: bytes):
    flags = int.from_bytes(data[0:2], byteorder='little')
    idx = 2

    def read_uint8():
        nonlocal idx
        val = data[idx]
        idx += 1
        return val

    def read_uint16():
        nonlocal idx
        val = int.from_bytes(data[idx:idx+2], 'little')
        idx += 2
        return val

    def read_sint16():
        nonlocal idx
        val = int.from_bytes(data[idx:idx+2], 'little', signed=True)
        idx += 2
        return val

    def read_uint24():
        nonlocal idx
        val = int.from_bytes(data[idx:idx+3] + b'\x00', 'little')
        idx += 3
        return val

    parsed = {}

    if (flags & 0x01) == 0:
        parsed["speed_kmh"] = read_uint16() / 100.0

    if flags & (1 << 1):
        parsed["average_speed_kmh"] = read_uint16() / 100.0

    if flags & (1 << 2):
        parsed["distance_km"] = read_uint24() / 1000.0

    if flags & (1 << 3):
        parsed["incline_percent"] = read_sint16() / 10.0
        idx += 2  # Skip Ramp Angle Setting

    if flags & (1 << 4):
        parsed["positive_elevation_gain_m"] = read_uint16()
        parsed["negative_elevation_gain_m"] = read_uint16()

    if flags & (1 << 5):
        parsed["instantaneous_pace_sec_per_km"] = read_uint16()

    if flags & (1 << 6):
        parsed["average_pace_sec_per_km"] = read_uint16()

    if flags & (1 << 7):
        parsed["total_energy_kcal"] = read_uint16()
        parsed["energy_per_hour_kcal"] = read_uint16()
        parsed["energy_per_minute_kcal"] = read_uint8()

    if flags & (1 << 8):
        parsed["heart_rate_bpm"] = read_uint8()

    if flags & (1 << 9):
        parsed["metabolic_equivalent"] = read_uint8() / 10.0

    if flags & (1 << 10):
        parsed["elapsed_time_s"] = read_uint16()

    if flags & (1 << 11):
        parsed["remaining_time_s"] = read_uint16()

    if flags & (1 << 12):
        parsed["force_on_belt_n"] = read_sint16()
        parsed["power_output_w"] = read_sint16()

    #return parsed

    values = (
        parsed.get("speed_kmh"),
        parsed.get("distance_km"),
        parsed.get("incline_percent"),
        parsed.get("elapsed_time_s")
    )

    #print(f"[TEST MODE] Parsed treadmill data: speed={values[0]}, distance={values[1]}, incline={values[2]}, elapsed_time={values[3]}")

    return values

    
--- End of treadmill_control.py ---

[File] treadmill_log.json
--- Start of treadmill_log.json ---
[
  {
    "timestamp": "2025-07-07T18:27:08.630671",
    "raw": "8c055000000000000005000000630074000700",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.08,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:10.430616",
    "raw": "8c055000000000000005000000630074000900",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.08,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:11.450592",
    "raw": "8c055000000000000005000000630074000a00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.08,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:12.230583",
    "raw": "8c055000000000000005000000630074000b00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.08,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:13.250533",
    "raw": "8c056400000000000005000000630074000c00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.1,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:14.270598",
    "raw": "8c05a0000000000000050000007700d0000d00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:14.930474",
    "raw": "8c05d2000000000000050000008c002c000e00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.21,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:15.950501",
    "raw": "8c050401000000000005000000a00088000f00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.26,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:16.850313",
    "raw": "8c053601000000000005000000a00088000f00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.31,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:17.870717",
    "raw": "8c055401000000000005000000b1008c001000",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.34,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:18.590422",
    "raw": "8c055e01000000000005000000bf0074001100",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.35,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:19.610142",
    "raw": "8c055e01000000000005000000bf0074001200",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 0.35,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:20.630069",
    "raw": "8c055e010a0000000005000000bf0074001300",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.71,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:21.290334",
    "raw": "8c055e010a0000000005000000bf0074001400",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.71,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:22.310034",
    "raw": "8c055e010a0000000005000000bf0074001500",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.71,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:23.329443",
    "raw": "8c055e010a0000000005000000bf0074001600",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.71,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:23.990326",
    "raw": "8c0586010a0000000005000000c90004001700",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.75,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:25.010297",
    "raw": "8c05b8010a0000000005000000dd0060001800",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.8,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:26.030523",
    "raw": "8c05cc010a0000000005000000dd0060001800",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.82,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:26.690227",
    "raw": "8c05ea010a0000000005000000e700f0001900",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.85,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:27.770186",
    "raw": "8c05f4010a0000000005000100ee0064001a00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.86,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:28.490314",
    "raw": "8c05f4010a0000000005000100f10080001b00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.86,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:29.510334",
    "raw": "8c05f4010a0000000005000100f10080001c00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 655.86,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:30.529831",
    "raw": "8c05f401140000000005000100f10080001d00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:31.189814",
    "raw": "8c05f401140000000005000100f10080001e00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:32.090194",
    "raw": "8c05f401140000000005000100f10080001f00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:33.110080",
    "raw": "8c05f401140000000005000100f10080002000",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:33.889744",
    "raw": "8c05f401140000000005000100f10080002100",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:34.910059",
    "raw": "8c05f401140000000005000100f10080002100",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:35.929998",
    "raw": "8c05f401140000000005000100f10080002200",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:36.590014",
    "raw": "8c05f401140000000005000100f10080002300",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1311.22,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:37.610040",
    "raw": "8c051c021e0000000005000100f10080002400",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1966.62,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:38.689963",
    "raw": "8c054e021e00000000050001000601dc002500",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1966.67,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:39.289956",
    "raw": "8c0580021e00000000050001001a01fc002600",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1966.72,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:40.309928",
    "raw": "8c05bc021e000000000500020016020c002700",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1966.78,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:41.329986",
    "raw": "8c05ee021e0000000005000200380250002800",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 1966.83,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:42.049895",
    "raw": "8c0520032800000000050002006102cc002900",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 2622.24,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:43.129900",
    "raw": "8c0534032800000000050002007502ec002a00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 2622.26,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:43.909843",
    "raw": "8c0570032800000000050002007502ec002a00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 2622.32,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:44.929511",
    "raw": "8c05a2032800000000050002009e02a4002b00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 2622.37,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:45.649800",
    "raw": "8c05ca03280000000005000200c002ac002c00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 2622.41,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:46.669827",
    "raw": "8c05e803320000000005000300e202b4002d00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3277.8,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:47.689687",
    "raw": "8c05e803320000000005000300f0029c002e00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3277.8,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:48.349494",
    "raw": "8c05e803320000000005000300f0029c002f00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3277.8,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:49.369727",
    "raw": "8c05e803320000000005000300f0029c003000",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3277.8,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:50.389804",
    "raw": "8c05e8033c0000000005000300f0029c003100",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3933.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:51.109480",
    "raw": "8c05e8033c0000000005000400f0029c003200",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3933.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:52.129681",
    "raw": "8c05e8033c0000000005000400f0029c003300",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3933.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:52.849723",
    "raw": "8c05e8033c0000000005000400f0029c003300",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3933.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:53.929669",
    "raw": "8c05e8033c0000000005000400f0029c003400",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 3933.16,
      "incline_percent": 0.0,
      "elapsed_time_s": 327680
    }
  },
  {
    "timestamp": "2025-07-07T18:27:54.649584",
    "raw": "8c05e8034600000a0005000400f0029c003500",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 4588.52,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:27:55.669197",
    "raw": "8c05e8034600000a00050005000e0388003600",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 4588.52,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:27:56.689553",
    "raw": "8c05e8034600000a00050005000e0388003700",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 4588.52,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:27:57.349649",
    "raw": "8c05e8035000000a00050005000e0388003800",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5243.88,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:27:58.369226",
    "raw": "8c05e8035000000a00050005000e0388003900",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5243.88,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:27:59.389551",
    "raw": "8c05e8035000000a00050005000e0388003a00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5243.88,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:00.049456",
    "raw": "8c05e8035000000a00050006000e0388003b00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5243.88,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:01.068930",
    "raw": "8c05e8035a00000a00050006000e0388003c00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5899.24,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:02.089513",
    "raw": "8c05e8035a00000a00050006000e0388003c00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5899.24,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:02.748659",
    "raw": "8c05e8035a00000a00050006000e0388003d00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5899.24,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:03.768971",
    "raw": "8c05e8035a00000a00050006000e0388003e00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 5899.24,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:04.848968",
    "raw": "8c05e8036400000a00050006000e0388003f00",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 6554.6,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:05.509918",
    "raw": "8c05e8036400000a00050007000e0388004000",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 6554.6,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:06.589116",
    "raw": "8c05e8036400000a00050007000e0388004100",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 6554.6,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  },
  {
    "timestamp": "2025-07-07T18:28:07.309692",
    "raw": "8c05e8036400000a00050007000e0388004200",
    "parsed": {
      "speed_kmh": null,
      "distance_km": 6554.6,
      "incline_percent": 0.0,
      "elapsed_time_s": 327690
    }
  }
]
--- End of treadmill_log.json ---

[File] user_config.json
--- Start of user_config.json ---

{
  "pb_times_minutes": {
    "1": 5.0,
    "3": 19.0,
    "5": 32.33,
    "10": 115.0,
    "21": 140.0
  },
  "goal_times_minutes": {
    "1": 5.0,
    "3": 18.0,
    "5": 30.0,
    "10": 60.0,
    "21": 135.0
  }
}
--- End of user_config.json ---

[File] video_playback.py
--- Start of video_playback.py ---
import cv2
import asyncio
import time
import platform
from ghost_runner_hud import GhostRunnerHUD

def get_screen_resolution():
    if platform.system() == "Windows":
        return 1280, 720  # You can change this as needed
    try:
        import subprocess
        output = subprocess.check_output("xrandr | grep '*' | awk '{print $1}'", shell=True)
        width, height = output.decode().strip().split('x')
        return int(width), int(height)
    except Exception as e:
        print("Could not determine screen resolution:", e)
        return 1280, 720

async def play_video(video_path, speed_ratio_queue, speed_queue, distance_queue, elapsed_time_queue, ghost_gap_queue, exit_signal):
    cap = cv2.VideoCapture(video_path)
    last_known_speed = 0.0
    last_known_distance = 0.0
    elapsed_time_seconds = 0
    last_ghost_gaps = {}
    speed_ratio = 1.0
    ghost_runner_hud = GhostRunnerHUD()
    confirm_exit = False
    esc_pressed_once = False

    screen_width, screen_height = get_screen_resolution()

    # Create fullscreen window once
    cv2.namedWindow("Video", cv2.WINDOW_NORMAL)
    cv2.setWindowProperty("Video", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        try:
            speed_ratio = speed_ratio_queue.get_nowait()
        except asyncio.QueueEmpty:
            pass

        try:
            last_known_speed = speed_queue.get_nowait()
        except asyncio.QueueEmpty:
            pass

        try:
            last_known_distance = distance_queue.get_nowait()
        except asyncio.QueueEmpty:
            pass

        try:
            last_ghost_gaps = ghost_gap_queue.get_nowait()
        except asyncio.QueueEmpty:
            pass

        # HUD: Speed
        hud_speed_text = f"{last_known_speed:.1f} km/h"
        cv2.putText(frame, hud_speed_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        # HUD: Distance
        hud_distance_text = f"{last_known_distance:.2f} km"
        (text_width, text_height), _ = cv2.getTextSize(hud_distance_text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
        cv2.putText(frame, hud_distance_text, (frame.shape[1] - text_width - 10, text_height + 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        # HUD: Elapsed Time
        try:
            elapsed_time_seconds = elapsed_time_queue.get_nowait()
        except asyncio.QueueEmpty:
            pass
        hud_time_text = f"Time: {int(elapsed_time_seconds // 60)}:{int(elapsed_time_seconds % 60):02d}"
        cv2.putText(frame, hud_time_text, (10, frame.shape[0] - 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        # HUD: Ghost Gaps (split left/right)
        if last_ghost_gaps:
            left_labels = []
            right_labels = []

            for name, gap in last_ghost_gaps.items():
                if name.startswith("PB") or name.startswith("Goal"):
                    left_labels.append((name, gap))
                else:
                    right_labels.append((name, gap))

            
            # Draw left-aligned labels (above time label)
            y_offset_left = frame.shape[0] - 60  # 30 for time label + 30 buffer
            for name, gap in sorted(left_labels, key=lambda x: x[1], reverse=True):
                gap_text = f"{name}: {'+' if gap >= 0 else ''}{gap:.1f} m"
                cv2.putText(frame, gap_text, (10, y_offset_left),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)
                y_offset_left -= 25



            # Draw right-aligned labels
            y_offset_right = frame.shape[0] - 30
            for name, gap in sorted(right_labels, key=lambda x: x[1], reverse=True):
                gap_text = f"{name}: {'+' if gap >= 0 else ''}{gap:.1f} m"
                (text_width, _), _ = cv2.getTextSize(gap_text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)
                x_position = frame.shape[1] - text_width - 10
                cv2.putText(frame, gap_text, (x_position, y_offset_right),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)
                y_offset_right -= 25

            ghost_runner_hud.draw_ghost_runners(frame, last_ghost_gaps)


        # Exit Confirmation Overlay
        if confirm_exit:
            overlay = frame.copy()
            cv2.rectangle(overlay, (200, 200), (600, 400), (0, 0, 0), -1)
            cv2.putText(overlay, "Exit workout?", (250, 270), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 2)
            cv2.putText(overlay, "Y = Yes, ESC = No", (250, 320), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
            alpha = 0.7
            cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0, frame)

        # Resize to screen resolution
        frame = cv2.resize(frame, (screen_width, screen_height))

        # Show frame
        cv2.imshow("Video", frame)

        safe_ratio = max(speed_ratio, 0.1)  # prevent zero or too slow
        key = cv2.waitKey(int(1000 / (30 * safe_ratio))) & 0xFF


        if not confirm_exit and key in [27, 8, 38]:  # ESC or BACK
            confirm_exit = True
            esc_pressed_once = True
        elif confirm_exit:
            if key in [ord('y'), ord('Y'), 13, 10]:  # Y or Enter
                await exit_signal.put(True)
                break
            elif key in [ord('n'), ord('N')]:
                confirm_exit = False
            elif key in [27, 8, 38] and esc_pressed_once:
                confirm_exit = False
                esc_pressed_once = False

        await asyncio.sleep(0)

    cap.release()
    cv2.destroyAllWindows()
--- End of video_playback.py ---

[Folder] videos/
    [File] video_thumbnails.py
    --- Start of video_thumbnails.py ---
    import cv2
    from pathlib import Path
    
    def generate_video_thumbnail(video_path, timestamp=1.0):
        """
        Generates a thumbnail image for a given .mp4 video file at a specified timestamp.
        """
        video_file = Path(video_path)
        if not video_file.is_file() or video_file.suffix.lower() not in ['.mp4', '.avi']:
            print(f"Invalid .mp4 file: {video_path}")
            return
    
        thumbnail_path = video_file.with_suffix('.png')
        if thumbnail_path.exists():
            print(f"Thumbnail already exists: {thumbnail_path}")
            return
    
        # Open the video file
        cap = cv2.VideoCapture(str(video_file))
        if not cap.isOpened():
            print(f"Error opening video file: {video_path}")
            return
    
        # Calculate the frame number at the specified timestamp
        fps = cap.get(cv2.CAP_PROP_FPS)
        frame_number = int(fps * timestamp)
    
        # Set the video to the desired frame
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
    
        # Read the frame
        ret, frame = cap.read()
        if ret:
            # Save the frame as an image
            cv2.imwrite(str(thumbnail_path), frame)
            print(f"Thumbnail created: {thumbnail_path}")
        else:
            print(f"Error reading frame at {timestamp} seconds")
    
        # Release the video capture object
        cap.release()
    
    if __name__ == "__main__":
        current_dir = Path(".")
        video_files = list(current_dir.glob("*.mp4")) + list(current_dir.glob("*.avi"))
    
        if not video_files:
            print("No .mp4 files found in the current directory.")
        else:
            for video_file in video_files:
                generate_video_thumbnail(video_file)
    --- End of video_thumbnails.py ---

[File] virtual_competitors.py
--- Start of virtual_competitors.py ---
import random
from datetime import timedelta

def generate_competitor_profiles(user_duration_min, user_avg_speed, num_competitors=3):
    strategies = ["even", "positive_split", "negative_split", "mid_surge", "random"]
    competitors = []
    for i in range(num_competitors):
        variation = random.uniform(-0.025, 0.025)  # ¬±2.5% duration variation
        comp_time = user_duration_min * (1 + variation)
        comp_avg_speed = user_avg_speed * (user_duration_min / comp_time)  # Maintain same distance
        print(f"A ghost time is: {comp_time:.2f} min, with expected average speed of: {comp_avg_speed:.2f} km\n")
        strategy = random.choice(strategies)
        competitors.append({
            "name": f"Ghost {chr(65+i)}",
            "duration_min": comp_time,
            "avg_speed": comp_avg_speed,
            "strategy": strategy
        })
    return competitors

def normalize_speed_profile(speed_profile, target_avg, segment_duration_sec):
    total_distance = compute_total_distance(speed_profile, segment_duration_sec)
    expected_distance = target_avg * (segment_duration_sec * len(speed_profile) / 3600.0)
    scale = expected_distance / total_distance
    return [(t, speed * scale) for t, speed in speed_profile]

def generate_speed_profile(duration_min, avg_speed, strategy):
    segments = 10
    segment_duration = duration_min * 60 / segments
    speed_profile = []

    if strategy == "even":
        for i in range(segments):
            speed_profile.append((i * segment_duration, avg_speed))
    elif strategy == "positive_split":
        for i in range(segments):
            speed = avg_speed + (i / segments) * (avg_speed * 0.2)
            speed_profile.append((i * segment_duration, speed))
    elif strategy == "negative_split":
        for i in range(segments):
            speed = avg_speed - (i / segments) * (avg_speed * 0.2)
            speed_profile.append((i * segment_duration, speed))
    elif strategy == "mid_surge":
        for i in range(segments):
            speed = avg_speed * 1.2 if segments // 3 <= i < 2 * segments // 3 else avg_speed
            speed_profile.append((i * segment_duration, speed))
    elif strategy == "random":
        for i in range(segments):
            speed = random.uniform(avg_speed * 0.8, avg_speed * 1.2)
            speed_profile.append((i * segment_duration, speed))

    return normalize_speed_profile(speed_profile, avg_speed, segment_duration)

def compute_total_distance(speed_profile, segment_duration_sec):
    total = 0.0
    for _, speed in speed_profile:
        total += speed * (segment_duration_sec / 3600.0)  # Convert to km
    return total

def generate_competitors_with_profiles(user_duration_min, user_avg_speed, num_competitors=3):
    competitors = generate_competitor_profiles(user_duration_min, user_avg_speed, num_competitors)
    for competitor in competitors:
        duration_min = competitor["duration_min"]
        strategy = competitor["strategy"]
        avg_speed = competitor["avg_speed"]

        speed_profile = generate_speed_profile(duration_min, avg_speed, strategy)
        competitor["speed_profile"] = speed_profile

        # ‚ûï Add time difference to name
        time_diff_sec = (duration_min - user_duration_min) * 60
        if abs(time_diff_sec) < 1:
            delta_str = "¬±0s"
        elif time_diff_sec > 0:
            delta_str = f"+{int(round(time_diff_sec))}s"
        else:
            delta_str = f"{int(round(time_diff_sec))}s"

        competitor["base_name"] = competitor["name"]

    return competitors

if __name__ == "__main__":
    user_duration_min = 33
    user_avg_speed = 10.0  # km/h
    user_distance = user_avg_speed * (user_duration_min / 60.0)

    competitors = generate_competitors_with_profiles(user_duration_min, user_avg_speed)

    print(f"User target: {user_duration_min:.2f} min, Distance: {user_distance:.2f} km\n")

    for competitor in competitors:
        name = competitor["name"]
        duration = competitor["duration_min"]
        avg_speed = competitor["avg_speed"]
        strategy = competitor["strategy"]
        speed_profile = competitor["speed_profile"]
        segment_duration = (duration * 60) / len(speed_profile)
        total_distance = compute_total_distance(speed_profile, segment_duration)

        print(f"Competitor: {name}")
        print(f"  Strategy: {strategy}")
        print(f"  Target Duration: {duration:.2f} min")
        print(f"  Target Distance: {total_distance:.2f} km")
        print("  Speed Profile:")
        for timestamp, speed in speed_profile:
            print(f"    {str(timedelta(seconds=timestamp))} ‚Äî {speed:.2f} km/h")
        print()
--- End of virtual_competitors.py ---

[File] zwo_parser.py
--- Start of zwo_parser.py ---
import xml.etree.ElementTree as ET
import os

def parse_zwo_file(file_path, starting_speed):
    """
    Parses a single ZWO file and converts it into a routine format.
    Each interval's speed is calculated as (power * starting_speed),
    and the speed increment is (target_speed - starting_speed).
    """
    tree = ET.parse(file_path)
    root = tree.getroot()

    routine_name = root.find('name').text.strip()
    duration_type_elem = root.find('durationType')
    duration_type = duration_type_elem.text.strip().lower() if duration_type_elem is not None else "time"

    routine = []

    for block in root.find('workout'):
        duration_sec = int(block.attrib.get('Duration', 0))
        duration_min = duration_sec / 60

        if 'Power' in block.attrib:
            power = float(block.attrib['Power'])
        else:
            power_low = float(block.attrib.get('PowerLow', 0))
            power_high = float(block.attrib.get('PowerHigh', 0))
            power = (power_low + power_high) / 2

        target_speed = power * starting_speed
        speed_increment = target_speed - starting_speed
        routine.append((duration_min, speed_increment))

    return {routine_name: {"type": duration_type, "segments": routine}}

def load_all_zwo_routines(folder_path, starting_speed):
    """
    Loads all .zwo files in the given folder and returns a dictionary
    of routines using the starting speed as the 5k pace.
    """
    routines = {}
    for file in os.listdir(folder_path):
        if file.lower().endswith('.zwo'):
            full_path = os.path.join(folder_path, file)
            try:
                routines.update(parse_zwo_file(full_path, starting_speed))
            except Exception as e:
                print(f"Failed to parse {file}: {e}")
    return routines
--- End of zwo_parser.py ---

